## [G-01] - can avoid doing external call to rollup twice
https://github.com/code-423n4/2024-05-arbitrum-foundation/blob/6f861c85b281a29f04daacfe17a2099d7dad5f8f/src/bridge/SequencerInbox.sol#L103C1-L106C6
```
    modifier onlyRollupOwner() {
        if (msg.sender != rollup.owner()) revert NotOwner(msg.sender, rollup.owner());
        _;
    }
```

https://github.com/code-423n4/2024-05-arbitrum-foundation/blob/6f861c85b281a29f04daacfe17a2099d7dad5f8f/src/bridge/SequencerInbox.sol#L208C1-L210C67
```
    function updateRollupAddress() external {
        if (msg.sender != IOwnable(rollup).owner())
            revert NotOwner(msg.sender, IOwnable(rollup).owner());
```
external calls to other contracts cost gas additional gas, doing it twice is rather unneccessary as the data being read can be saved to a local variable and then  reused in memory.

### Recommened Mitigation
save `rollup.owner()` to local variable and  use the local variable in function logic. 


```
    modifier onlyRollupOwner() {
        address rollUpOwner = rollup.owner();
        if (msg.sender != rollUpOwner) revert NotOwner(msg.sender, rollUpOwner); //@audit can avoid two external calls here to rollup here too
        _;
    }
```

```
    function updateRollupAddress() external {
        address owner = rollUp.owner();
        if (msg.sender != owner)
            revert NotOwner(msg.sender, owner); 
```


## [L-01] - user's legit Pool creation tx can be frontran and caused to fail
https://github.com/code-423n4/2024-05-arbitrum-foundation/blob/6f861c85b281a29f04daacfe17a2099d7dad5f8f/src/assertionStakingPool/AssertionStakingPoolCreator.sol#L19
```
    function createPool(
        address _rollup,
        bytes32 _assertionHash
    ) external returns (IAssertionStakingPool) {
        AssertionStakingPool assertionPool = new AssertionStakingPool{salt: 0}(_rollup, _assertionHash);
```
https://github.com/code-423n4/2024-05-arbitrum-foundation/blob/6f861c85b281a29f04daacfe17a2099d7dad5f8f/src/assertionStakingPool/EdgeStakingPoolCreator.sol#L19
```
    function createPool(
        address challengeManager,
        bytes32 edgeId
    ) external returns (IEdgeStakingPool) {
        EdgeStakingPool pool = new EdgeStakingPool{salt: 0}(challengeManager, edgeId);
```

the code in the function attempts to create a new contract via solidity's "new" keyword. By default  "new" should cause solitity to use 'CREATE' opcode to depoly new contracts but since a salt value is provided, solidity is forced to use 'CREATE2'. More info [here](https://docs.soliditylang.org/en/v0.8.25/control-structures.html#salted-contract-creations-create2). 

Since CREATE2 is used, the salt is 0 and not provided by user or in anyway unique to each deployment or managed internally by the contract, it can be possible to generate in runtime the same creator address, salt and new contract's init code (CREATE2 parameters). The creator address will always be the deploying contract, the salt is always 0(hardcoded) and the new contract's  init code + constructor can be regenerated by an attacker by watching the mempool, getting the user's createPool() tx parameters and  front running the tx with its own tx and using the same parameters. 
This will cause the user's tx to fail if attackers tx is included in the block before users's tx and the user will not get the new Pool address back as a return value. 

### Recommended Mitigation
to mitigate this the salt value can be made to be more unique to each call. For example instead of it being 0 it can be the msg.sender value. 
